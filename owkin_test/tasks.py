from tempfile import SpooledTemporaryFile, TemporaryDirectory
from pathlib import Path
import json

import docker

from . import celery

# TODO: should be in a configuration file or better created on the fly (if it does not imply huge performance drops)
TRIVY_CACHE = "./trivy_cache"

client = docker.from_env()

# TODO: there is a lot of way this task may fail. Celery handles exceptions propagation so we may keep it like this,
# but keeping the dockerfile content if there is any problem may help reproduce.


@celery.task()
def analyse_dockerfile(dockerfile_content):
    # First step, we build the image corresponding to the dockerfile.
    # We write the dockerfile and then build it using docker-py
    # We use a temporary file to avoid handling the naming, the directory and the deletion.
    # We will use a spooledtemporary for performance purpose (not written on the file system except if its huge)
    with SpooledTemporaryFile() as tempf:
        tempf.write(dockerfile_content)
        response = [line for line in docker_client.build(fileobj=tempf)]
        # The image id is generated by the docker daemon and is unique. We may get the image id from the response of docker build.
        # We may use a tag or an image name but we need to use an uuid4 to handle naming collision in that case.
        image_id = "1234556789"  # Get in from the reponse using a regex.

    trivy = client.containers.run(
        "aquasec/trivy",
        f"{image_id}",
        volumes={TRIVY_CACHE: {"bind": "/root/.cache/", "mode": "rw"},},
    )

    # We should now analyse the results from trivy.
    problems = analyse_trivy_results(trivy.logs())
    if problems:
        return {"success": False, "error": problems}

    # Now, we run the container. The running environment should be secured. For the moment, we will only remove network access.
    # We use a temp directory to avoid name colision and folder deletion.
    with TemporaryDirectory() as data_dir:
        client.containers.run(
            image_id,
            volumes={data_dir.name: {"bind": "/data", "mode": "rw"},},
            network_disabled=True,
        )
        perf_json = Path(data_dir.name) / "perf.json"
        perf = json.load(perf_json)
        return {"success": True, "perf": perf["perf"]}


def analyse_trivy_results(logs):
    # To be implemented
    return None
